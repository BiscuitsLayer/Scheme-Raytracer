=== LAMBDA IDEA ===

Как сделать вложенные лямбды и возможность передавать лямбды как аргументы в функцию и т.д.
(сделаю, скорее всего, позже)

1. Указатели на функцию - BuildLambdaCodegen должен возвращать указатель на функцию с возможностью 
далее его интерпретировать именно как указатель на функцию
!!! ВАЖНО !!! для этого в SchemeObject надо добавить:
void* function и ObjectType::TYPE_FUNCTION в соответствующий enum

2. Далее все текущие имеющиеся функции необходимо сделать лямбдами (то есть отдельными функциями 
в IR коде) + возможно !!! с вариабельным !!! числом входящих аргументов (например для
функции сложения или сравнения, где число входных аргументов не определено)

=== SCOPE IDEA ===

Это то, что я реализую сейчас
Случай вложеных лямбд пока не работает (постараюсь обойтись без него)
Однако у каждой лямбды мб свой набор локальных переменных
+ она также должна видеть переменные из внешнего scope

1. (Решение для случая вложенных лямбд)
Каждая лямбда это объект класса Lambda
у этого класса есть единственный метод - тело этого метода == тело самой лямбды
также у этого класса есть переменные - это 
ВСЕ (наверное это плохо, но я не придумал как лучше) переменные из окружающих его scope-ов
при создании лямбды создается экзмепляр такого класса и сохраняются значения всех переменных

СТРАТЕГИЯ ВЫШЕ ПОКА ПЛОХО ПРОДУМАНА И НУЖДАЕТСЯ В ДОРАБОТКЕ

2. (Решение на текущий момент)
Делаем все переменные main-a глобальными объектами (потому что доступ к ним есть из всех лямбд)
Получаем значени переменной через поиск по имени глобального объекта
Звучит прикольно и вроде бы должно сработать
